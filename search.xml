<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[封装，继承，复制]]></title>
    <url>%2Fblog%2F2018%2F02%2F02%2F</url>
    <content type="text"><![CDATA[1 封装1.1 构造函数1234567891011121314function Cat(name,color)&#123; this.name=name; this.color=color; this.say = function() &#123; console.log(this.name) &#125;&#125;var cat1 = new Cat("大毛","黄色");var cat2 = new Cat("二毛","黑色");alert(cat1.constructor == Cat); //truealert(cat1 instanceof Cat); //truealert(cat2 instanceof Cat); //true 构造函数进行封装的问题在于，如果在其内部定义某个函数，则他的每一个实例对象在生成的过程中都要创建一个函数，占用内存。 1.2 prototype模式1234567891011121314151617181920function Cat() &#123; this.name = name; this.color = color;&#125;;Cat.prototype.say = function() &#123; alert(this.name) &#125;;Cat.prototype.type="animal";var cat1 = new Cat("大毛", "黄色"); var cat2 = new Cat("二毛", "黑色"); alert(cat1.say()); //大毛alert(cat2.say()); //二毛alert(Cat.prototype.isPrototypeOf(cat1)); //true alert(Cat.prototype.isPrototypeOf(cat2)); //true alert(cat1.hasOwnProperty("name")); // true alert(cat1.hasOwnProperty("type")); // false alert("name" in cat1); // true alert("type" in cat1); // true prototype是函数拥有的特殊属性，他是一个指针指向函数的原型对象，此函数的实例对象都可以访问原型对象上的属性和方法。 inPrototypeOf:此方法传入一个实例对象，返回一个布尔值判断调用函数的原型对象是否在参数对象的原型链上。 instanceof:此运算符用来检测对象的原型链上是否有此构造函数的prototype属性。 hasOwnProperty:参数是否是对象自身的属性。 in:运算符，参数事发后在对象属性或原型链上。 2 函数的继承(构造函数)2.1 使用CALL,APPLY12345678910111213function Animal() &#123; this.say = function() &#123; console.log("wojiao :" + this.name) &#125;&#125;function Cat(name, color) &#123; Animal.call(this) this.name = name; this.color = color;&#125;var cat1=new Cat("mimi",red);cat1.say()//"wojiao :mimi" call: 方法调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。返回值是你调用的方法的返回值，若该方法没有返回值，则返回undefined。可以使用call()来实现继承：写一个方法，然后让另外一个新的对象来继承它（而不是在新对象中再写一次这个方法）。 2.2 使用prototype1234567891011function Animal() &#123; this.say = function() &#123; console.log("wojiao :" + this.name) &#125;&#125;function Cat(name, color) &#123; this.name = name; this.color = color;&#125;Cat.prototype=new Animal();Cat.prototype.constructor=Cat; 这里需要注意的是，在Cat.prototype赋值一个新对象后，原型对象上的constructor属性将指向那个新对象，在上述例子中constructor是Animal，这会导致继承链的紊乱，所以需要再手动将constructor指向原函数Cat。 2.3 直接继承prototype123456789101112function Animal() &#123;&#125;;Animal.prototype.say = function() &#123; console.log("wojiao :" + this.name) &#125;;Animal.prototype.type= "animal";function Cat(name, color) &#123; this.name = name; this.color = color;&#125;;Cat.prototype=Animal.prototype;Cat.prototype.constructor=Cat; 这个方法是对上个方法的改进，由于构造函数的属性都可以写在prototype上，所以直接跳过Animal()，直接继承Animal.prototype;当然这样做也是有问题的，他们都指向了同一个对象，对Cat.prototype上的任意修改都会影响到Animal.prototype。比如：12Cat.prototype.constructor=Cat;//这里其实对Animal.prototype也一样进行了赋值console.log(Animal.prototype.constructor）;//Cat 2.4 利用空对象作为中介12345678910111213141516171819202122232425function Animal() &#123;&#125;;Animal.prototype.say = function() &#123; console.log("wojiao :" + this.name) &#125;;function Cat(name, color) &#123; this.name = name; this.color = color;&#125;;function extend(child,parent)&#123; var F=function()&#123;&#125;; F.prototype=Animal.prototype; var o=new F(); child.prototype=o; child.prototype.constructor=child;&#125;//使用方法如下extend(Cat,Animal);var cat=ew Cat("大毛","黄色");console.log(cat.say());//"wojiao :大毛" 上一个例子的方法会出现原型对象同指向同一个对象，在这个例子中，我们利用一个空函数，来复制Animal.prototype，再将空函数的实例赋值给Cat.prototype。把这个过程写成一个函数，这样就规避了上一个例子中出现的问题。算是比较好的一种继承的方法。1console.log(Animal.prototype.construcotr);//Animal，修改并没有影响Animal 2.5 拷贝继承1234567891011121314151617181920212223242526function extendCopy(child, parent) &#123; var p = parent.prototype; var c = child.prototype; for (var i in p) &#123; c[i] = p[i]; &#125;&#125;function Person() &#123;&#125;Person.prototype.nation = "china";Person.prototype.age = "0--100";Person.prototype.say = function() &#123; console.log("我的名字是：", this.name);&#125;function Worker() &#123; this.name = "worker";&#125;extendCopy(Worker,Person);var std1=new Worker();console.log(std1.nation);//中国 这里存在一个问题，如果Person.prototype的属性有数组或者对象的话，那么最后继承Person的对象在修改其继承属性的时候，对Person.prototype上的属性有影响，因为他们在程序内部都指向同一个数组或者对象。 12345678910111213141516Person.prototype.team=[1,2,3,4];Person.prototype.type=&#123;color:'red'&#125;;function Worker2() &#123; this.name = "worker2";&#125;extendCopy(Worker2,Person);var std2=new Worker2();std2.team.push(5);std2.type['color']='black';console.log(Person.prototype.team);//[1,2,3,4,5]console.log(Person.prototype.type.color);//black 3 非构造函数的继承什么是非构造函数的继承？123456 var Chinese = &#123; nation:'中国' &#125;; var Doctor =&#123; career:'医生' &#125; 这是两个都是普通的对象，如果创建出中国医生对象，他们都不是构造函数，不能用构造函数的继承。 3.1 object方法123456789101112131415function object(o) &#123; var F = function() &#123;&#125;; F.prototype = o; return new F();&#125;var Chinese = &#123; nation: '中国'&#125;;var Doctor=object(Chinese);Doctor.career='医生';console.log(Doctor.nation);//中国 创建一个object方法，逻辑是内部创建一个空函数，将prototype属性赋值需要继承的父对象Chinese,最后返回这个空函数的实例，得到原型链中有父对象的对象，再为其赋值即可。 3.2 浅拷贝1234567891011function extendCopy(p) &#123; var c = &#123;&#125;; for (var i in p) &#123; c[i] = p[i] &#125; return c;&#125;var Doctor = extendCopy(Chinese);Doctor.career = '医生';alert(Doctor.nation); // 中国 这个方法和2.5例子一样，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。 3.3深拷贝所谓’深拷贝’就是可以真正实现数组和对象的拷贝，其实就是递归调用’浅拷贝’。 12345678910111213141516171819202122232425function deepCopy(p,c)&#123; var _c=c||&#123;&#125;; for(var i in p)&#123; //判断p[i]是否是对象 if(typeof p[i]=='object')&#123; //判断是否是数组，做出相应的初始化 _c[i]=(p[i].constructor==Array)?[]:&#123;&#125;; deepCopy(p[i],_c[i]); &#125;else&#123; //不是。直接复制 _c[i]=p[i]; &#125; &#125; return _c;&#125;var Doctor = deepCopy(Chinese);Chinese.birthPlaces = ['北京','上海','香港'];Doctor.birthPlaces.push('厦门');alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门alert(Chinese.birthPlaces); //北京, 上海, 香港 目前，jQuery库使用的就是这种继承方法。]]></content>
      <tags>
        <tag>封装</tag>
        <tag>继承</tag>
        <tag>复制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[md的常用语法]]></title>
    <url>%2Fblog%2F2018%2F01%2F25%2F</url>
    <content type="text"><![CDATA[大标题小标题#这是标题 ##这是小标题 这是有序雷柏啊 这是有序列表 个人编程，写一个命令行程序 注册Github账号，建立项目仓库 添加ReadMe.md并编辑，描述项目的简要介绍、功能、用例、下载、文档等 建立doc目录存放文档 这是个链接 这是个目录12 功利主义是一种在西方影响巨大的伦理学说，其原则是“最大多数人的最大幸福”，以行为的实际功效或利益为判断行为正当与否的标准。本书系统地阐述了这一学说，分绪论、何谓功利主义、论功利主义最后制裁力、功利主义可以得到什么样的证明、论公道与功利主义之关系。 – 引用自《功利主义》 写一段代码 1234567891011121314151617181920212223242526272829303132333435363738大标题==小标题--#这是标题##这是小标题 1. 这是有序雷柏啊2. 这是有序列表- 个人编程，写一个命令行程序 - 注册Github账号，建立项目仓库 - 添加ReadMe.md并编辑，描述项目的简要介绍、功能、用例、下载、文档等 - 建立doc目录存放文档[这是个链接](http://www.baidu.com)这是个目录[1](SDF)[2](32)写一段代码var a=1,b=2;function foo(a,b)&#123; return a+b;&#125; foo()/***随便写点注释**/&gt;功利主义是一种在西方影响巨大的伦理学说，其原则是“最大多-- 引用自《[功利主义](https://book.douban.com/subject/3072490/)》]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决微信视频强制全屏播放]]></title>
    <url>%2Fblog%2F2018%2F01%2F25%2F</url>
    <content type="text"><![CDATA[微信浏览器VIDEO标签在播放视频的时候，会强制的全屏播放，有如下办法可以解决： 1&lt;video src="" controls="" x5-playsinline="" playsinline="" webkit-playsinline="" poster="" preload="auto"&gt;&lt;/video&gt;]]></content>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一个博客]]></title>
    <url>%2Fblog%2F2018%2F01%2F19%2F</url>
    <content type="text"><![CDATA[Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake Welcome to Marxico@(Sample notebook)[Marxico|Manual|Markdown] Marxico is a delicate Markdown editor for Evernote. With reliable storage and sync powered by Evernote, Marxico offers greate writing experience. Versatile - supporting code highlight, LaTeX &amp; flow charts, inserting images &amp; attachments by all means. Exquisite - neat but powerful editor, featuring offline docs, live preview, and offering the desktop client and offline Chrome App. Sophisticated - deeply integrated with Evernote, supporting notebook &amp; tags, two-way bind editing. [TOC] Introducing Markdown Markdown is a plain text formatting syntax designed to be converted to HTML. Markdown is popularly used as format for readme files, … or in text editors for the quick creation of rich text documents. - Wikipedia As showed in this manual, it uses hash(#) to identify headings, emphasizes some text to be bold or italic. You can insert a link , or a footnote[^demo]. Serveral advanced syntax are listed below, please press Ctrl + / to view Markdown cheatsheet. Code block12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' LaTeX expression$$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$ Table Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 DiagramsFlow charts12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op Sequence diagrams123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! Note: You can find more information: about Sequence diagrams syntax here, about Flow charts syntax here. CheckboxYou can use - [ ] and - [x] to create checkboxes, for example: Item1 Item2 Item3 Note: Currently it is only partially supported. You can’t toggle checkboxes in Evernote. You can only modify the Markdown in Marxico to do that. Next version will fix this. Dancing with EvernoteNotebook &amp; TagsMarxico add @(Notebook)[tag1|tag2|tag3] syntax to select notebook and set tags for the note. After typing @(, the notebook list would appear, please select one from it. TitleMarxico would adopt the first heading encountered as the note title. For example, in this manual the first line Welcome to Marxico is the title. Quick EditingNote saved by Marxico in Evernote would have a red ribbon button on the top-right corner. Click it and it would bring you back to Marxico to edit the note. Note: Currently Marxico is unable to detect and merge any modifications in Evernote by user. Please go back to Marxico to edit. Data SynchronizationWhile saving rich HTML content in Evernote, Marxico puts the Markdown text in a hidden area of the note, which makes it possible to get the original text in Marxico and edit it again. This is a really brilliant design because: it is beyond just one-way exporting HTML which other services do; and it avoids privacy and security problems caused by storing content in a intermediate server. Privacy Statement: All of your notes data are saved in Evernote. Marxico doesn’t save any of them. Offline StorageMarxico stores your unsynchronized content locally in browser storage, so no worries about network and broswer crash. It also keeps the recent file list you’ve edited in Document Management(Ctrl + O). Note: Although browser storage is reliable in the most time, Evernote is born to do that. So please sync the document regularly while writing. ShortcutsHelp Ctrl + /Sync Doc Ctrl + SCreate Doc Ctrl + Alt + NMaximize Editor Ctrl + EnterPreview Doc Ctrl + Alt + EnterDoc Management Ctrl + OMenu Ctrl + M Bold Ctrl + BInsert Image Ctrl + GInsert Link Ctrl + LConvert Heading Ctrl + H About ProMarixo offers a free trial of 10 days. After that, you need to purchase the Pro service. Otherwise, you would not be able to sync new notes. Previous notes can be edited and synced all the time. CreditsMarxico was first built upon Dillinger, and the newest version is almost based on the awesome StackEdit. Acknowledgments to them and other incredible open source projects! Feedback &amp; Bug Report Twitter: @gock2 Email: &#x68;&#117;&#x73;&#x74;&#103;&#111;&#x63;&#x6b;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109; Thank you for reading this manual. Now please press Ctrl + M and click Link with Evernote. Enjoy your Marxico journey! [^demo]: This is a demo footnote. Read the MultiMarkdown Syntax Guide to learn more. Note that Evernote disables ID attributes in its notes , so footnote and TOC are not actually working.]]></content>
      <tags>
        <tag>这是标签</tag>
      </tags>
  </entry>
</search>
